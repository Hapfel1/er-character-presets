name: Process Preset Submission via PR

on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  create-pr-from-issue:
    if: contains(github.event.issue.labels.*.name, 'preset-submission')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pillow
      
      - name: Parse issue and extract data
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            console.log('Parsing issue #' + issue.number);
            
            // Extract data
            const nameMatch = body.match(/\*\*Preset Name:\*\*\s*(.+)/);
            const authorMatch = body.match(/\*\*Author:\*\*\s*(.+)/);
            const tagsMatch = body.match(/\*\*Tags:\*\*\s*(.+)/);
            const descMatch = body.match(/\*\*Description:\*\*\s*\n([\s\S]+?)\n\n---/);
            
            if (!nameMatch || !authorMatch || !tagsMatch || !descMatch) {
              throw new Error('Missing required fields');
            }
            
            const presetName = nameMatch[1].trim();
            const author = authorMatch[1].trim();
            const tags = tagsMatch[1].trim();
            const description = descMatch[1].trim();
            
            // Extract JSON
            const jsonMatch = body.match(/```json\s*\n([\s\S]+?)\n```/);
            if (!jsonMatch) {
              throw new Error('Missing appearance JSON');
            }
            
            const appearance = JSON.parse(jsonMatch[1]);
            
            core.setOutput('preset_name', presetName);
            core.setOutput('author', author);
            core.setOutput('tags', tags);
            core.setOutput('description', description);
            core.setOutput('appearance_json', JSON.stringify(appearance));
            core.setOutput('issue_number', issue.number);
      
      - name: Generate preset ID
        id: generate_id
        run: |
          if [ -f index.json ]; then
            LAST_ID=$(jq -r '.presets[-1].id // "preset_000"' index.json)
            NUM=$(echo $LAST_ID | sed 's/preset_0*//')
            NEXT_NUM=$((NUM + 1))
            PRESET_ID=$(printf "preset_%03d" $NEXT_NUM)
          else
            PRESET_ID="preset_001"
          fi
          
          echo "preset_id=$PRESET_ID" >> $GITHUB_OUTPUT
      
      - name: Download and extract ZIP from issue
        id: download_images
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const fs = require('fs');
            const https = require('https');
            const { execSync } = require('child_process');
            
            const body = issue.body || '';
            
            // Look for ZIP file attachment
            // GitHub attaches files as: [filename.zip](https://github.com/...)
            const zipRegex = /\[([^\]]+\.zip)\]\((https:\/\/[^)]+)\)/gi;
            const zipMatches = [...body.matchAll(zipRegex)];
            
            console.log(`Found ${zipMatches.length} ZIP files`);
            
            let hasImages = false;
            
            if (zipMatches.length > 0) {
              // Download first ZIP file
              const zipUrl = zipMatches[0][2];
              const zipFilename = 'preset_images.zip';
              
              console.log(`Downloading ZIP from: ${zipUrl}`);
              
              await new Promise((resolve, reject) => {
                https.get(zipUrl, (response) => {
                  if (response.statusCode === 302 || response.statusCode === 301) {
                    https.get(response.headers.location, (redirectResponse) => {
                      const file = fs.createWriteStream(zipFilename);
                      redirectResponse.pipe(file);
                      file.on('finish', () => {
                        file.close();
                        resolve();
                      });
                      file.on('error', reject);
                    }).on('error', reject);
                  } else {
                    const file = fs.createWriteStream(zipFilename);
                    response.pipe(file);
                    file.on('finish', () => {
                      file.close();
                      resolve();
                    });
                    file.on('error', reject);
                  }
                }).on('error', reject);
              });
              
              // Extract ZIP
              console.log('Extracting ZIP...');
              execSync(`unzip -o ${zipFilename}`);
              
              // Check for extracted images
              const hasFace = fs.existsSync('face.png') || fs.existsSync('face.jpg') || fs.existsSync('face.jpeg');
              const hasBody = fs.existsSync('body.png') || fs.existsSync('body.jpg') || fs.existsSync('body.jpeg');
              const hasPreview = fs.existsSync('preview.png') || fs.existsSync('preview.jpg') || fs.existsSync('preview.jpeg');
              
              console.log(`Extracted images - Face: ${hasFace}, Body: ${hasBody}, Preview: ${hasPreview}`);
              
              hasImages = hasFace || hasBody;
              
              core.setOutput('has_face', hasFace ? 'true' : 'false');
              core.setOutput('has_body', hasBody ? 'true' : 'false');
              core.setOutput('has_preview', hasPreview ? 'true' : 'false');
              core.setOutput('has_images', hasImages ? 'true' : 'false');
            } else {
              // Fallback: look for individual images (legacy support)
              const imageRegex = /!\[([^\]]*)\]\((https:\/\/[^)]+)\)/g;
              const images = [...body.matchAll(imageRegex)];
              
              console.log(`No ZIP found, checking for individual images: ${images.length}`);
              
              const imageMap = { 'face': null, 'body': null, 'preview': null };
              
              for (const match of images) {
                const altText = match[1].toLowerCase();
                const url = match[2];
                
                let imageType = null;
                if (altText.includes('face')) imageType = 'face';
                else if (altText.includes('body')) imageType = 'body';
                else if (altText.includes('preview')) imageType = 'preview';
                
                if (imageType && !imageMap[imageType]) {
                  const ext = url.match(/\.(png|jpg|jpeg|gif)(\?|$)/i)?.[1] || 'png';
                  const filename = `${imageType}.${ext}`;
                  
                  await new Promise((resolve, reject) => {
                    https.get(url, (response) => {
                      if (response.statusCode === 302 || response.statusCode === 301) {
                        https.get(response.headers.location, (redirectResponse) => {
                          const file = fs.createWriteStream(filename);
                          redirectResponse.pipe(file);
                          file.on('finish', () => { file.close(); resolve(); });
                          file.on('error', reject);
                        }).on('error', reject);
                      } else {
                        const file = fs.createWriteStream(filename);
                        response.pipe(file);
                        file.on('finish', () => { file.close(); resolve(); });
                        file.on('error', reject);
                      }
                    }).on('error', reject);
                  });
                  
                  imageMap[imageType] = filename;
                }
              }
              
              hasImages = imageMap.face || imageMap.body;
              core.setOutput('has_face', imageMap.face ? 'true' : 'false');
              core.setOutput('has_body', imageMap.body ? 'true' : 'false');
              core.setOutput('has_preview', imageMap.preview ? 'true' : 'false');
              core.setOutput('has_images', hasImages ? 'true' : 'false');
            }
      
      - name: Create preset files
        run: |
          PRESET_ID="${{ steps.generate_id.outputs.preset_id }}"
          PRESET_NAME="${{ steps.parse.outputs.preset_name }}"
          AUTHOR="${{ steps.parse.outputs.author }}"
          TAGS="${{ steps.parse.outputs.tags }}"
          DESCRIPTION="${{ steps.parse.outputs.description }}"
          APPEARANCE='${{ steps.parse.outputs.appearance_json }}'
          
          mkdir -p presets
          
          # Create JSON
          TAGS_ARRAY=$(echo "$TAGS" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";""))')
          CREATED_DATE=$(date +%Y-%m-%d)
          
          jq -n \
            --arg id "$PRESET_ID" \
            --arg name "$PRESET_NAME" \
            --arg author "$AUTHOR" \
            --arg description "$DESCRIPTION" \
            --argjson tags "$TAGS_ARRAY" \
            --argjson appearance "$APPEARANCE" \
            --arg screenshot "presets/${PRESET_ID}.png" \
            --arg created "$CREATED_DATE" \
            '{
              id: $id,
              name: $name,
              author: $author,
              description: $description,
              tags: $tags,
              appearance: $appearance,
              screenshot_url: $screenshot,
              downloads: 0,
              created: $created
            }' > presets/${PRESET_ID}.json
          
          # Copy images
          HAS_FACE="${{ steps.download_images.outputs.has_face }}"
          HAS_BODY="${{ steps.download_images.outputs.has_body }}"
          HAS_PREVIEW="${{ steps.download_images.outputs.has_preview }}"
          
          if [ "$HAS_FACE" = "true" ]; then
            for ext in png jpg jpeg; do
              if [ -f "face.$ext" ]; then
                cp "face.$ext" "presets/${PRESET_ID}_face.png"
                cp "face.$ext" "presets/${PRESET_ID}.png"
                break
              fi
            done
          fi
          
          if [ "$HAS_BODY" = "true" ]; then
            for ext in png jpg jpeg; do
              if [ -f "body.$ext" ]; then
                cp "body.$ext" "presets/${PRESET_ID}_body.png"
                if [ "$HAS_FACE" != "true" ]; then
                  cp "body.$ext" "presets/${PRESET_ID}.png"
                fi
                break
              fi
            done
          fi
          
          if [ "$HAS_PREVIEW" = "true" ]; then
            for ext in png jpg jpeg; do
              if [ -f "preview.$ext" ]; then
                cp "preview.$ext" "presets/${PRESET_ID}_preview.png"
                break
              fi
            done
          fi
      
      - name: Update index.json
        run: |
          PRESET_ID="${{ steps.generate_id.outputs.preset_id }}"
          PRESET_NAME="${{ steps.parse.outputs.preset_name }}"
          AUTHOR="${{ steps.parse.outputs.author }}"
          TAGS="${{ steps.parse.outputs.tags }}"
          DESCRIPTION="${{ steps.parse.outputs.description }}"
          
          if [ ! -f index.json ]; then
            cat > index.json << 'EOF'
          {
            "version": "1.0.0",
            "last_updated": "",
            "base_url": "https://raw.githubusercontent.com/${{ github.repository }}/main/",
            "presets": []
          }
          EOF
          fi
          
          TAGS_ARRAY=$(echo "$TAGS" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";""))')
          CREATED_DATE=$(date +%Y-%m-%d)
          UPDATED_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          INDEX_ENTRY=$(jq -n \
            --arg id "$PRESET_ID" \
            --arg name "$PRESET_NAME" \
            --arg author "$AUTHOR" \
            --arg description "$DESCRIPTION" \
            --argjson tags "$TAGS_ARRAY" \
            --arg data_url "presets/${PRESET_ID}.json" \
            --arg screenshot_url "presets/${PRESET_ID}.png" \
            --arg created "$CREATED_DATE" \
            '{
              id: $id,
              name: $name,
              author: $author,
              description: $description,
              tags: $tags,
              data_url: $data_url,
              screenshot_url: $screenshot_url,
              downloads: 0,
              created: $created
            }')
          
          jq --argjson entry "$INDEX_ENTRY" \
             --arg updated "$UPDATED_TIME" \
             '.presets += [$entry] | .last_updated = $updated' \
             index.json > index.tmp && mv index.tmp index.json
      
      - name: Create Pull Request
        id: create_pr
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Add preset: ${{ steps.parse.outputs.preset_name }} by ${{ steps.parse.outputs.author }}"
          branch: preset-${{ steps.generate_id.outputs.preset_id }}
          delete-branch: true
          title: "[Preset] ${{ steps.parse.outputs.preset_name }} by ${{ steps.parse.outputs.author }}"
          body: |
            ## Preset from Issue #${{ steps.parse.outputs.issue_number }}
            
            **ID:** `${{ steps.generate_id.outputs.preset_id }}`
            **Name:** ${{ steps.parse.outputs.preset_name }}
            **Author:** ${{ steps.parse.outputs.author }}
            
            **Review and merge to add preset.**
            
            Original issue: #${{ steps.parse.outputs.issue_number }}
          labels: preset-submission
      
      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ steps.create_pr.outputs.pull-request-number }}';
            const prUrl = '${{ steps.create_pr.outputs.pull-request-url }}';
            
            if (prNumber && prUrl) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.parse.outputs.issue_number }},
                body: `## ✅ Preset Processed!\n\n` +
                      `PR created: ${prUrl}\n\n` +
                      `The maintainer will review and merge. Thank you!`
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.parse.outputs.issue_number }},
                labels: ['pr-created']
              });
            }
      
      - name: Handle errors
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `## ❌ Processing Failed\n\nCheck [workflow run](${context.payload.repository.html_url}/actions/runs/${context.runId})`
            });
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['processing-failed']
            });
