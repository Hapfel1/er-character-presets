name: Process Preset Submission via PR

on:
  issues:
    types: [opened, labeled]

# CRITICAL: Prevent concurrent runs that could create duplicate IDs
concurrency:
  group: preset-submission
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  create-pr-from-issue:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pillow
      
      - name: Parse issue and extract data
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            console.log('Parsing issue #' + issue.number);
            
            // Extract data
            const nameMatch = body.match(/\*\*Preset Name:\*\*\s*(.+)/);
            const authorMatch = body.match(/\*\*Author:\*\*\s*(.+)/);
            const tagsMatch = body.match(/\*\*Tags:\*\*\s*(.+)/);
            const descMatch = body.match(/\*\*Description:\*\*\s*\n([\s\S]+?)\n\n---/);
            
            if (!nameMatch || !authorMatch || !tagsMatch || !descMatch) {
              throw new Error('Missing required fields');
            }
            
            const name = nameMatch[1].trim();
            const author = authorMatch[1].trim();
            const tags = tagsMatch[1].trim();
            const description = descMatch[1].trim();
            
            // Extract appearance JSON
            const jsonMatch = body.match(/```json\s*([\s\S]+?)\s*```/);
            if (!jsonMatch) {
              throw new Error('No appearance JSON found');
            }
            
            const appearance = JSON.parse(jsonMatch[1]);
            
            core.setOutput('preset_name', name);
            core.setOutput('author', author);
            core.setOutput('tags', tags);
            core.setOutput('description', description);
            core.setOutput('appearance', JSON.stringify(appearance));
            
            console.log(`Extracted: ${name} by ${author}`);
      
      - name: Download images from ZIP
        id: download_images
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const https = require('https');
            const { execSync } = require('child_process');
            
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            console.log('=== Starting ZIP download ===');
            
            // Find attachment URL - try multiple patterns
            const patterns = [
              /https:\/\/github\.com\/[^\/]+\/[^\/]+\/files\/\d+\/[^\s)]+\.zip/g,
              /https:\/\/github\.com\/user-attachments\/files\/\d+\/[^\s)]+\.zip/g,
              /\[([^\]]+\.zip)\]\((https:\/\/[^)]+)\)/gi
            ];
            
            let zipUrl = null;
            for (const pattern of patterns) {
              const matches = body.match(pattern);
              if (matches && matches.length > 0) {
                zipUrl = matches[0];
                // If it's markdown format, extract URL from parens
                if (zipUrl.includes('](')) {
                  const urlMatch = zipUrl.match(/\((https:\/\/[^)]+)\)/);
                  if (urlMatch) zipUrl = urlMatch[1];
                }
                break;
              }
            }
            
            if (!zipUrl) {
              console.log('‚ùå No ZIP attachment found in issue body');
              console.log('Issue body preview:', body.substring(0, 500));
              core.setOutput('has_face', 'false');
              core.setOutput('has_body', 'false');
              core.setOutput('has_preview', 'false');
              return;
            }
            
            console.log('‚úÖ Found ZIP URL:', zipUrl);
            
            // Download ZIP
            const zipFilename = 'preset_images.zip';
            
            try {
              await new Promise((resolve, reject) => {
                const downloadFile = (url, attempt = 1) => {
                  console.log(`Downloading (attempt ${attempt})...`);
                  
                  https.get(url, { 
                    headers: { 'User-Agent': 'GitHub-Actions' }
                  }, (response) => {
                    // Handle redirects
                    if (response.statusCode === 302 || response.statusCode === 301) {
                      const redirectUrl = response.headers.location;
                      console.log(`Following redirect to: ${redirectUrl}`);
                      downloadFile(redirectUrl, attempt);
                      return;
                    }
                    
                    if (response.statusCode !== 200) {
                      reject(new Error(`HTTP ${response.statusCode}`));
                      return;
                    }
                    
                    const file = fs.createWriteStream(zipFilename);
                    response.pipe(file);
                    
                    file.on('finish', () => {
                      file.close();
                      const size = fs.statSync(zipFilename).size;
                      console.log(`‚úÖ Downloaded ${size} bytes`);
                      resolve();
                    });
                    
                    file.on('error', (err) => {
                      fs.unlinkSync(zipFilename);
                      reject(err);
                    });
                  }).on('error', reject);
                };
                
                downloadFile(zipUrl);
              });
            } catch (err) {
              console.log('‚ùå Download failed:', err.message);
              core.setOutput('has_face', 'false');
              core.setOutput('has_body', 'false');
              core.setOutput('has_preview', 'false');
              return;
            }
            
            // Extract ZIP
            console.log('=== Extracting ZIP ===');
            try {
              const output = execSync('unzip -o preset_images.zip', { encoding: 'utf8' });
              console.log('Extraction output:', output);
              
              // List extracted files
              const files = execSync('ls -la', { encoding: 'utf8' });
              console.log('Files after extraction:\n', files);
            } catch (err) {
              console.log('‚ùå Extraction failed:', err.message);
              core.setOutput('has_face', 'false');
              core.setOutput('has_body', 'false');
              core.setOutput('has_preview', 'false');
              return;
            }
            
            // Check for images (case-insensitive)
            console.log('=== Checking for images ===');
            
            const checkImage = (name) => {
              const variations = [
                `${name}.png`, `${name}.PNG`,
                `${name}.jpg`, `${name}.JPG`,
                `${name}.jpeg`, `${name}.JPEG`
              ];
              for (const file of variations) {
                if (fs.existsSync(file)) {
                  console.log(`‚úÖ Found: ${file}`);
                  return true;
                }
              }
              console.log(`‚ùå Not found: ${name}.*`);
              return false;
            };
            
            const hasFace = checkImage('face');
            const hasBody = checkImage('body');
            const hasPreview = checkImage('preview');
            
            console.log(`\n=== Results ===`);
            console.log(`Face: ${hasFace}, Body: ${hasBody}, Preview: ${hasPreview}`);
            
            core.setOutput('has_face', hasFace ? 'true' : 'false');
            core.setOutput('has_body', hasBody ? 'true' : 'false');
            core.setOutput('has_preview', hasPreview ? 'true' : 'false');

      
      - name: Generate preset ID with gap-filling and octal fix
        id: generate_id
        run: |
          ISSUE_NUM="${{ github.event.issue.number }}"
          
          # Get all existing IDs from index.json and filesystem
          USED_IDS=()
          
          # From index.json
          if [ -f index.json ]; then
            while IFS= read -r id; do
              # Skip empty or invalid IDs
              if [ -z "$id" ] || ! [[ "$id" =~ ^[0-9]+$ ]]; then
                continue
              fi
              # Strip leading zeros immediately (fixes octal bug)
              id=$((10#$id))
              USED_IDS+=("$id")
            done < <(jq -r '.presets[].id' index.json 2>/dev/null | grep -oP 'preset_\K\d+' || true)
          fi
          
          # From filesystem (in case of orphaned folders)
          if [ -d presets ]; then
            while IFS= read -r folder; do
              if [[ "$folder" =~ preset_([0-9]+) ]]; then
                id_str="${BASH_REMATCH[1]}"
                # Skip invalid
                if [ -z "$id_str" ] || ! [[ "$id_str" =~ ^[0-9]+$ ]]; then
                  continue
                fi
                # Strip leading zeros
                num=$((10#$id_str))
                USED_IDS+=("$num")
              fi
            done < <(ls -d presets/preset_* 2>/dev/null | xargs -n1 basename || true)
          fi
          
          # Remove duplicates and sort
          USED_IDS=($(printf '%s\n' "${USED_IDS[@]}" | sort -n | uniq))
          
          echo "üìã Used IDs: ${USED_IDS[*]}"
          
          # Find next available ID (fill gaps first)
          PRESET_ID=""
          for i in {0..999}; do
            FOUND=false
            
            for used in "${USED_IDS[@]}"; do
              if [ "$used" = "$i" ]; then
                FOUND=true
                break
              fi
            done
            
            if [ "$FOUND" = false ]; then
              PRESET_ID=$(printf "preset_%03d" $i)
              break
            fi
          done
          
          # Fallback to issue-based ID if all slots full
          if [ -z "$PRESET_ID" ]; then
            echo "‚ö†Ô∏è All numeric IDs used (0-999), using issue-based ID"
            PRESET_ID="preset_i${ISSUE_NUM}"
          fi
          
          # Double-check folder doesn't exist
          if [ -d "presets/$PRESET_ID" ]; then
            echo "‚ö†Ô∏è Collision detected for $PRESET_ID, using issue-based ID"
            PRESET_ID="preset_i${ISSUE_NUM}"
          fi
          
          echo "preset_id=$PRESET_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Generated ID: $PRESET_ID (issue #$ISSUE_NUM)"

      
      - name: Create preset folder and data
        run: |
          PRESET_ID="${{ steps.generate_id.outputs.preset_id }}"
          APPEARANCE='${{ steps.parse.outputs.appearance }}'
          
          mkdir -p "presets/${PRESET_ID}"
          echo "$APPEARANCE" | jq '.' > "presets/${PRESET_ID}/data.json"
      
      - name: Copy images
        run: |
          PRESET_ID="${{ steps.generate_id.outputs.preset_id }}"
          HAS_FACE="${{ steps.download_images.outputs.has_face }}"
          HAS_BODY="${{ steps.download_images.outputs.has_body }}"
          HAS_PREVIEW="${{ steps.download_images.outputs.has_preview }}"
          
          # Face
          if [ "$HAS_FACE" = "true" ]; then
            for ext in png jpg jpeg; do
              if [ -f "face.$ext" ]; then
                cp "face.$ext" "presets/${PRESET_ID}/face.png"
                [ "$HAS_PREVIEW" != "true" ] && cp "face.$ext" "presets/${PRESET_ID}/preview.png"
                break
              fi
            done
          fi
          
          # Body
          if [ "$HAS_BODY" = "true" ]; then
            for ext in png jpg jpeg; do
              if [ -f "body.$ext" ]; then
                cp "body.$ext" "presets/${PRESET_ID}/body.png"
                [ "$HAS_FACE" != "true" ] && [ "$HAS_PREVIEW" != "true" ] && cp "body.$ext" "presets/${PRESET_ID}/preview.png"
                break
              fi
            done
          fi
          
          # Preview (overrides)
          if [ "$HAS_PREVIEW" = "true" ]; then
            for ext in png jpg jpeg; do
              [ -f "preview.$ext" ] && cp "preview.$ext" "presets/${PRESET_ID}/preview.png" && break
            done
          fi
          
          # Cleanup
          rm -f face.* body.* preview.* *.zip
      
      - name: Update index.json
        run: |
          PRESET_ID="${{ steps.generate_id.outputs.preset_id }}"
          PRESET_NAME="${{ steps.parse.outputs.preset_name }}"
          AUTHOR="${{ steps.parse.outputs.author }}"
          TAGS="${{ steps.parse.outputs.tags }}"
          DESCRIPTION="${{ steps.parse.outputs.description }}"
          HAS_FACE="${{ steps.download_images.outputs.has_face }}"
          HAS_BODY="${{ steps.download_images.outputs.has_body }}"
          
          [ ! -f index.json ] && echo '{"version":"1.0.0","last_updated":"","base_url":"https://raw.githubusercontent.com/${{ github.repository }}/main/","presets":[]}' > index.json
          
          TAGS_ARRAY=$(echo "$TAGS" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";""))')
          CREATED=$(date +%Y-%m-%d)
          UPDATED=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # Build entry
          ENTRY=$(jq -n \
            --arg id "$PRESET_ID" \
            --arg name "$PRESET_NAME" \
            --arg author "$AUTHOR" \
            --argjson tags "$TAGS_ARRAY" \
            --arg desc "$DESCRIPTION" \
            --arg created "$CREATED" \
            '{id: $id, name: $name, author: $author, tags: $tags, description: $desc, created: $created, data_url: ("presets/" + $id + "/data.json"), screenshot_url: ("presets/" + $id + "/preview.png")}')
          
          # Add URLs conditionally
          [ "$HAS_FACE" = "true" ] && ENTRY=$(echo "$ENTRY" | jq --arg id "$PRESET_ID" '. + {face_url: ("presets/" + $id + "/face.png")}')
          [ "$HAS_BODY" = "true" ] && ENTRY=$(echo "$ENTRY" | jq --arg id "$PRESET_ID" '. + {body_url: ("presets/" + $id + "/body.png")}')
          
          # Add to index
          jq --argjson entry "$ENTRY" --arg updated "$UPDATED" \
             '.presets += [$entry] | .last_updated = $updated' \
             index.json > index.tmp && mv index.tmp index.json
      
      - name: Create PR
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "feat: add preset ${{ steps.generate_id.outputs.preset_id }}"
          branch: preset-${{ steps.generate_id.outputs.preset_id }}
          title: "[Preset] ${{ steps.parse.outputs.preset_name }}"
          body: |
            **ID:** ${{ steps.generate_id.outputs.preset_id }}
            **Author:** ${{ steps.parse.outputs.author }}
            
            Closes #${{ github.event.issue.number }}
          labels: preset-submission
      
      - name: Comment on issue
        if: steps.create_pr.outputs.pull-request-number
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚úÖ PR created: #${{ steps.create_pr.outputs.pull-request-number }}\n\n**ID:** \`${{ steps.generate_id.outputs.preset_id }}\``
            });
